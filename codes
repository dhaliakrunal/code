package com.sunscreening.jsonreader.util;

import com.sunscreening.jsonreader.model.*;

import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

public class CsvExportUtil {

    public static void exportToCsv(List<MergedOutput> mergedData, String filePath) {
        try (FileWriter writer = new FileWriter(filePath)) {

            // CSV Header
            writer.write("CRDS CODE;Reg Address;Reg Address Country;BNPP Site;Site Country;Site Status;KYC Segment;Risk Industry\n");

            for (MergedOutput entity : mergedData) {
                StringBuilder line = new StringBuilder();

                // 1. CRDS CODE
                String crdsCode = "";
                if (entity.getIdentifiers() != null && !entity.getIdentifiers().isEmpty()) {
                    Identifiers id = entity.getIdentifiers().get(0);
                    if (id.getCrdsCode() != null) {
                        crdsCode = id.getCrdsCode();
                    }
                }
                line.append(crdsCode).append(";");

                // 2. Registration Address + Country
                String fullAddress = "";
                String regCountry = "";
                RegistrationAddress regAddress = entity.getRegistrationAddress();
                if (regAddress != null) {
                    String line1 = regAddress.getLine1() != null ? regAddress.getLine1() : "";
                    String line2 = regAddress.getLine2() != null ? regAddress.getLine2() : "";
                    String city = regAddress.getCity() != null ? regAddress.getCity() : "";
                    String state = regAddress.getState() != null ? regAddress.getState() : "";
                    String zip = regAddress.getZipCode() != null ? regAddress.getZipCode() : "";

                    fullAddress = (line1 + " " + line2 + " " + city + " " + state + " " + zip).trim();
                    regCountry = regAddress.getCountry() != null ? regAddress.getCountry() : "";
                }
                line.append(fullAddress).append(";");
                line.append(regCountry).append(";");

                // 3. KYC Site
                String bnppSite = "", siteCountry = "", siteStatus = "";
                if (entity.getKycSite() != null && !entity.getKycSite().isEmpty()) {
                    KycSite site = entity.getKycSite().get(0);
                    bnppSite = site.getSiteBnpp() != null ? site.getSiteBnpp() : "";
                    siteCountry = site.getSiteCountry() != null ? site.getSiteCountry() : "";
                    siteStatus = site.getSiteStatus() != null ? site.getSiteStatus() : "";
                }
                line.append(bnppSite).append(";");
                line.append(siteCountry).append(";");
                line.append(siteStatus).append(";");

                // 4. KYC Segment
                String kycSegment = entity.getKycSegment() != null ? entity.getKycSegment() : "";
                line.append(kycSegment).append(";");

                // 5. Risk Industry
                String riskInfo = "";
                List<RiskIndustry> riskList = entity.getKycRiskIndustry();
                if (riskList != null && !riskList.isEmpty()) {
                    riskInfo = riskList.stream()
                            .map(r -> {
                                String code = r.getRiskIndustryCode() != null ? r.getRiskIndustryCode() : "";
                                String desc = r.getRiskIndustryDescription() != null ? r.getRiskIndustryDescription() : "";
                                return code + "-" + desc;
                            })
                            .collect(Collectors.joining("|"));
                }
                line.append(riskInfo).append("\n");

                writer.write(line.toString());
            }

            writer.flush();
            System.out.println("‚úÖ CSV exported to: " + filePath);

        } catch (IOException e) {
            System.err.println("‚ùå CSV export failed: " + e.getMessage());
            e.printStackTrace();
        }
    }
}






package com.sunscreening.jsonreader.controller;

import com.sunscreening.jsonreader.model.MergedOutput;
import com.sunscreening.jsonreader.service.JsonReaderService;
import com.sunscreening.jsonreader.util.CsvExportUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/report")
@RequiredArgsConstructor
public class CsvExportController {

    private final JsonReaderService jsonReaderService;

    @Value("${csv.output-path}")
    private String csvOutputPath;

    @GetMapping("/download")
    public ResponseEntity<String> downloadCsvReport() {
        // 1. Fetch merged data
        List<MergedOutput> mergedData = jsonReaderService.mergeAndDisplayData();

        // 2. Export to CSV
        CsvExportUtil.exportToCsv(mergedData, csvOutputPath);

        // 3. Return message
        return ResponseEntity.ok("‚úÖ CSV report generated at: " + csvOutputPath);
    }
}









package com.sunscreening.jsonreader.controller;

import com.sunscreening.jsonreader.config.CsvFileProperties;
import com.sunscreening.jsonreader.model.MergedOutput;
import com.sunscreening.jsonreader.service.JsonReaderService;
import com.sunscreening.jsonreader.util.CsvExportUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/report")
@RequiredArgsConstructor
public class CsvExportController {

    private final JsonReaderService jsonReaderService;
    private final CsvFileProperties csvFileProperties;

    @GetMapping("/download")
    public ResponseEntity<String> downloadCsvReport() {
        // Step 1: Fetch merged data
        List<MergedOutput> mergedData = jsonReaderService.mergeAndDisplayData();

        // Step 2: Export to CSV using configured path
        String outputPath = csvFileProperties.getOutputPath();
        CsvExportUtil.exportToCsv(mergedData, outputPath);

        // Step 3: Return success response
        return ResponseEntity.ok("‚úÖ CSV report generated at: " + outputPath);
    }
}






public List<MergedOutput> mergeAndDisplayData() {
    List<MergedOutput> mergedResults = new ArrayList<>();

    try {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        System.out.println("üîç Fetching access token...");
        String accessToken = fetchAccessTokenFromHeader();
        System.out.println("‚úÖ Access token received.");

        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(accessToken);
        headers.setAccept(List.of(MediaType.APPLICATION_JSON));
        headers.set("Accept", "*/*;version=gamma");

        HttpEntity<Void> request = new HttpEntity<>(headers);

        System.out.println("üåê Calling Entities API: " + apiProperties.getEntitiesUrl());
        ResponseEntity<String> entityResponse = restTemplate.exchange(
                apiProperties.getEntitiesUrl(),
                HttpMethod.GET,
                request,
                String.class
        );

        System.out.println("üì¶ Entity API response received. Parsing...");
        List<Wrapper> wrappers = mapper.readValue(entityResponse.getBody(), EntityResponse.class).getResults();

        List<Integer> allPtyIds = wrappers.stream()
                .filter(wrapper -> wrapper.getEntity() != null && wrapper.getEntity().getIdentifiers() != null)
                .flatMap(wrapper -> wrapper.getEntity().getIdentifiers().stream())
                .map(Identifiers::getPtyId)
                .filter(Objects::nonNull)
                .distinct()
                .toList();

        for (Integer ptyId : allPtyIds) {
            String kycUrlWithPtyId = apiProperties.getKycUrl() + "?ptyId=" + ptyId;
            System.out.println("üåê Calling KYC API for ptyId=" + ptyId);

            ResponseEntity<String> kycResponse = restTemplate.exchange(
                    kycUrlWithPtyId,
                    HttpMethod.GET,
                    request,
                    String.class
            );

            JsonNode resultsNode = null;
            List<KycDetails> kycList = new ArrayList<>();

            if (kycResponse.getStatusCode().is2xxSuccessful() &&
                kycResponse.getBody() != null && !kycResponse.getBody().isBlank()) {

                System.out.println("üì¶ KYC API response received for ptyId=" + ptyId);
                JsonNode root = mapper.readTree(kycResponse.getBody());
                resultsNode = root.get("results");

                if (resultsNode != null && resultsNode.isArray() && !resultsNode.isEmpty()) {
                    kycList = mapper.readValue(
                            resultsNode.toString(),
                            mapper.getTypeFactory().constructCollectionType(List.class, KycDetails.class)
                    );
                } else {
                    System.out.println("‚ö†Ô∏è No 'results' array found in KYC response for ptyId=" + ptyId);
                }
            } else {
                System.out.println("‚ùå KYC API failed or empty for ptyId=" + ptyId);
            }

            wrappers.stream()
                    .filter(wrapper -> wrapper.getEntity() != null && wrapper.getEntity().getIdentifiers() != null)
                    .filter(wrapper -> wrapper.getEntity().getIdentifiers().stream()
                            .anyMatch(id -> ptyId.equals(id.getPtyId())))
                    .forEach(wrapper -> {
                        MergedOutput output = new MergedOutput();
                        output.setIdentifiers(wrapper.getEntity().getIdentifiers());
                        output.setBusinessGroup(wrapper.getBusinessGroup());

                        for (KycDetails kyc : kycList) {
                            if (kyc != null && kyc.getKycData() != null && kyc.getIdentifiers() != null &&
                                    kyc.getIdentifiers().stream().anyMatch(id -> ptyId.equals(id.getPtyId()))) {
                                output.setKycSegment(kyc.getKycData().getKycSegment());
                                output.setKycSite(kyc.getKycData().getKycSite());
                                output.setKycRiskIndustry(kyc.getKycData().getRiskIndustry());
                                break;
                            }
                        }

                        mergedResults.add(output);
                    });
        }

        System.out.println("‚úÖ Merging complete. Total records: " + mergedResults.size());
        return mergedResults;

    } catch (Exception e) {
        System.err.println("‚ùå Error during merge: " + e.getMessage());
        e.printStackTrace(); // Log full stack trace for debugging
        throw new RuntimeException("‚ùå Error during merge: " + e.getMessage(), e);
    }
}

