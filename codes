package com.example.jsonreader.service;

import com.example.jsonreader.model.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

@Service
public class JsonReaderService {

    private final ObjectMapper mapper = new ObjectMapper();
    private final List<MergedOutput> mergedData = new ArrayList<>();

    @PostConstruct
    public void loadAndMergeData() {
        try {
            // Load KYC details
            InputStream kycStream = new ClassPathResource("kycDetails.json").getInputStream();
            KycDetailsWrapper kycWrapper = mapper.readValue(kycStream, KycDetailsWrapper.class);

            // Load entities
            InputStream entityStream = new ClassPathResource("entities.json").getInputStream();
            EntityResponse entityResponse = mapper.readValue(entityStream, EntityResponse.class);

            // Merge by kycId using List matching
            for (Wrapper w : entityResponse.getResults()) {
                EntityData entity = w.getEntity();
                if (entity != null && entity.getIdentifiers() != null && !entity.getIdentifiers().isEmpty()) {
                    Integer kycId = entity.getIdentifiers().get(0).getKycId();
                    if (kycId != null) {
                        for (KycDetails kd : kycWrapper.getResults()) {
                            if (kd.getIdentifiers() != null && !kd.getIdentifiers().isEmpty()
                                    && kycId.equals(kd.getIdentifiers().get(0).getKycId())) {
                                MergedOutput out = new MergedOutput();
                                out.setIdentifiers(entity.getIdentifiers());
                                out.setBusinessGroup(entity.getBusinessGroup());
                                out.setKycSegment(kd.getKycSegment());
                                out.setKycSite(kd.getKycSite());
                                out.setRiskIndustry(kd.getRiskIndustry());
                                mergedData.add(out);
                                break;
                            }
                        }
                    }
                }
            }

            // Print result to console
            if (mergedData.isEmpty()) {
                System.out.println("❌ No records merged.");
            } else {
                System.out.println("✅ Merged Records:");
                for (MergedOutput mo : mergedData) {
                    System.out.println(mo);
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public List<MergedOutput> getMergedData() {
        return mergedData;
    }
}






package com.example.jsonreader.controller;

import com.example.jsonreader.model.MergedOutput;
import com.example.jsonreader.service.JsonReaderService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class EntityController {

    private final JsonReaderService service;

    @GetMapping("/merged")
    public List<MergedOutput> getMergedData() {
        return service.getMergedData();
    }
}











package com.example.jsonreader;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import com.example.jsonreader.service.JsonReaderService;

@SpringBootApplication
public class JsonReaderApplication implements CommandLineRunner {

    private final JsonReaderService service;

    public JsonReaderApplication(JsonReaderService service) {
        this.service = service;
    }

    public static void main(String[] args) {
        SpringApplication.run(JsonReaderApplication.class, args);
    }

    @Override
    public void run(String... args) {
        // Data printed during @PostConstruct
    }
}









