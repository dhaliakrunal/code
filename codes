Let me provide the full updated and final versions of:

application.properties

JsonFileProperties.java

JsonReaderService.java

JsonReaderController.java (minor if change)

application.properties (already done)
json.entities-path=data/entities.json
json.kyc-path=data/kycDetails.json
json.output-path=merged_output.json

JsonFileProperties.java

package com.example.jsonreader.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Getter
@Setter
@Configuration
@ConfigurationProperties(prefix = "json")
public class JsonFileProperties {
private String entitiesPath;
private String kycPath;
private String outputPath;
}

JsonReaderService.java (Updated to use injected config)

package com.example.jsonreader.service;

import com.example.jsonreader.config.JsonFileProperties;
import com.example.jsonreader.model.*;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Service
public class JsonReaderService {

pgsql
Copy
Edit
private final JsonFileProperties properties;

public JsonReaderService(JsonFileProperties properties) {
    this.properties = properties;
}

public List<MergedOutput> mergeAndDisplayData() {
    List<MergedOutput> mergedResults = new ArrayList<>();

    try {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        // Read entities.json
        InputStream entityStream = new ClassPathResource(properties.getEntitiesPath()).getInputStream();
        EntityResponse entityResponse = mapper.readValue(entityStream, EntityResponse.class);
        List<Wrapper> wrappers = entityResponse.getResults();

        // Read kycDetails.json
        InputStream kycStream = new ClassPathResource(properties.getKycPath()).getInputStream();
        KycDetailsWrapper kycWrapper = mapper.readValue(kycStream, KycDetailsWrapper.class);
        List<KycDetails> kycDetailsList = kycWrapper.getResults();

        // Merge logic
        wrappers.stream()
                .filter(wrapper -> wrapper.getEntity() != null && wrapper.getEntity().getIdentifiers() != null)
                .forEach(wrapper -> {
                    List<Identifiers> entityIds = wrapper.getEntity().getIdentifiers();
                    entityIds.stream()
                            .filter(eid -> eid.getKycId() != null)
                            .forEach(entityId -> {
                                kycDetailsList.stream()
                                        .filter(kyc -> kyc.getIdentifiers() != null)
                                        .flatMap(kyc -> kyc.getIdentifiers().stream()
                                                .filter(kid -> kid.getKycId() != null && Objects.equals(kid.getKycId(), entityId.getKycId()))
                                                .map(kid -> new AbstractMap.SimpleEntry<>(kyc, kid)))
                                        .findFirst()
                                        .ifPresent(match -> {
                                            KycDetails kyc = match.getKey();

                                            MergedOutput output = new MergedOutput();
                                            output.setIdentifiers(entityIds);
                                            output.setBusinessGroup(wrapper.getBusinessGroup());

                                            if (kyc.getKycData() != null) {
                                                output.setKycSegment(kyc.getKycData().getKycSegment());
                                                output.setKycSite(kyc.getKycData().getKycSite());
                                                output.setKycRiskIndustry(kyc.getKycData().getRiskIndustry());
                                            }

                                            mergedResults.add(output);
                                        });
                            });
                });

        // Save to merged_output.json
        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(properties.getOutputPath()), mergedResults);
        System.out.println("‚úÖ Merged output saved to: " + properties.getOutputPath());

        // Print to console
        mergedResults.forEach(System.out::println);

    } catch (Exception e) {
        System.err.println("‚ùå Error during merging: " + e.getMessage());
        e.printStackTrace();
    }

    return mergedResults;
}
}

JsonReaderController.java (no change unless you renamed mergeAndDisplayData())

package com.example.jsonreader.controller;

import com.example.jsonreader.model.MergedOutput;
import com.example.jsonreader.service.JsonReaderService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class JsonReaderController {

kotlin
Copy
Edit
private final JsonReaderService jsonReaderService;

public JsonReaderController(JsonReaderService jsonReaderService) {
    this.jsonReaderService = jsonReaderService;
}

@GetMapping("/merged-output")
public List<MergedOutput> getMergedData() {
    return jsonReaderService.mergeAndDisplayData();
}
}

üìå Notes:

merged_output.json will be written to the project root directory unless you specify full path like json/output/merged_output.json.

Make sure you annotate @Configuration on JsonFileProperties and add @EnableConfigurationProperties(JsonFileProperties.class) in your main class or Spring Boot will not recognize the config.

Restart the app after setting application.properties.

Let me know if you want to move output to a specific folder or want a REST endpoint to download the file as well.
